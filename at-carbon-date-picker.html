<!--
Missing features needed for at-form-date
-- time picker
-- date / time switch
-- year/month fast switcher
-- single date mode
-- we need to defend against invalid formats because invalid format will poison the values. We should have a list of valid formats and allow use only those formats. Everything else should be rejected
-->

<link rel="import" href="../tangere/Tangere.html">
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="../at-i18n/at-i18n-behavior.html">
<link rel="import" href="../at-carbon-icon-button/at-carbon-icon-button.html">
<link rel="import" href="styles/styles.html">

<dom-module id="at-carbon-date-picker">
  <template>
    <style include="at-form-common"></style>
    <style include="at-carbon-date-picker-styles"></style>
    <style></style>
    <div class="calendar">
      <div class="calendar-header">
        <div class="calendar-row">
          <div class="calendar-button" on-tap="_backClicked">
            <at-carbon-icon class="calendar-icon" icon="arrow-left"></at-carbon-icon>
          </div>
          <div class="month-year-view">
            <div class="month-name">{{_monthName}}</div><div class="year">{{_year}}</div>
          </div>
          <div class="calendar-button" on-tap="_nextClicked">
            <at-carbon-icon class="calendar-icon" icon="arrow-right"></at-carbon-icon>
          </div>
        </div>
        <div class="calendar-row">
          <template is="dom-repeat" items="{{_daysOfWeek}}">
            <div class="weekday-name">{{item}}</div>
          </template>
        </div>
      </div>
      <div id="calendarBody" class="calendar-body" on-tap="_dateClicked">
        <div class="calendar-row">
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
        </div>
        <div class="calendar-row">
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
        </div>
        <div class="calendar-row">
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
        </div>
        <div class="calendar-row">
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
        </div>
        <div class="calendar-row">
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
        </div>
        <div class="calendar-row">
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
          <div class="day">day</div>
        </div>
      </div>
    </div>
  </template>
  <script>
    /**
     * fired when new startDate is selected from date-picker
     * @event start-date-changed
     */
     /**
      * fired when new endDate is selected from date-picker
      * @event end-date-changed
      */
    'use strict';
    Polymer({
      is: 'at-carbon-date-picker',
      behaviors: [ Tangere.behaviors.i18n ],
      properties: {
        /**
         * Holds the mode of operation for date-picker.
         * Two possible values "single" and "range"
         * single is used for at-form-date which operates on only one value
         * range is used for at-form-daterange which operates on start/end values
         */
        // mode: {
        //   type: String,
        //   value: 'single',
        //   observer: 'modeChanged'
        //   xtype: 'enum',
        //   xvaluelist: [{ title: "Single", value: "single"}, { title: "Range", value: "range"}]
        // }
        // when used in at-form-daterange start=true marks the date picker for start date
        // start: {
        //   type: Boolean,
        //   value: false
        // },
        /**
         * end property is used in at-form-daterange <br>
         * when true, date picker will mark end date of the range as selected date
         * and will update end date when selecting date from the date picker <br>
         * when false, date picker will mark start date of the range as selected date
         * and will update start date when selecting date from the date picker
         * @property end
         * @type boolean
         * @default false
         */
        end: {
          type: Boolean,
          value: false,
          observer: 'endChanged'
        },
        /**
         * holds the string value of the startDate of the date picker
         * @property startDate
         * @type String
         * @default ''
         */
        startDate: {
          type: String,
          value: '',
          observer: 'startDateChanged'
        },
        /**
         * holds the string value of the endDate of the date picker
         * @property endDate
         * @type String
         * @default ''
         */
        endDate: {
          type: String,
          value: '',
          observer: 'endDateChanged'
        },
        /**
         * holds the string value of the date format with which startDate and endDate values will be formatted
         * @property format
         * @type String
         * @default ''
         */
        format: {
          type: String,
          value: '',
          observer: 'formatChanged'
        }
      },
      ready: function () {
        this._initializeAtCarbonDatePicker();
      },
      _createLocaleMoment: function () {
        // getLocale function is from at-i18n; it gets the local from the browser settings
        var locale = this.getLocale();
        // we create localized moment instance
        var localeMoment = moment().locale(locale);

        return localeMoment;
      },
      _createCurrentMomentFor: function (dateMoment) {
        var locale = this.getLocale();
        var year = dateMoment.year();
        var month = dateMoment.month();
        var result = moment([year, month, 1]).locale(locale);
        return result;
      },
      // this function is called _initializeAtCarbonDatePicker because at-i18n already has a function called _initialize
      _initializeAtCarbonDatePicker: function () {
        if (this._isInitialized) {
          return;
        }
        this._isInitialized = true;

        // we create the new locale moment
        var localeMoment = this._createLocaleMoment();
        // _currentMoment is the month displayed in the calendar
        // we need this for next previous month navigation
        // and later, year, month jumping and setting time in at-form-date
        this._currentMoment = this._createCurrentMomentFor(localeMoment);

        // we need year to be displayed in the date-picker
        // we get this from localized moment instance
        this._year = localeMoment.year();
        // we get month name from localized moment instance
        this._monthName = localeMoment.format("MMMM");

        var localeClone = localeMoment.clone();
        // we figure out starting day of week for current locale
        var startOfWeekNum = localeClone.startOf('week').day();
        // by default we assume that sunday is the first day of week. hence 0_1_2_3_4_5_6
        var _daysOfWeekStr = "0_1_2_3_4_5_6";
        if (startOfWeekNum === 1) {
          // if startOfWeekNum is 1 that means that monday is first day of week hence 1_2_3_4_5_6_7
          _daysOfWeekStr = "1_2_3_4_5_6_7";
        }

        this._daysOfWeek = _daysOfWeekStr.split("_").map(function (n) {
          return localeClone.day(n).format("dd");
        });

        if (!this.format) {
          // if format is not specified use localized format from at-i18n
          this._internalFormatUpdate = true;
          this.format = this._localizedFormat("date");
          this._internalFormatUpdate = false;
        }
      },
      formatChanged: function (newValue, oldValue) {
        // we need to defend against invalid formats because invalid format will poison the values
        // we should have a list of valid formats and allow use only those formats
        // everything else should be rejected

        if (this._internalFormatUpdate) { return; }
        // this is the only changed callback called before ready function
        // so call _initializeAtCarbonDatePicker here
        this._initializeAtCarbonDatePicker();

        var format = newValue;
        if (!format) {
          format = this._localizedFormat("date");
        }
        if (!oldValue) {
          oldValue = format;
        }

        if (this.startDate === "" || this.endDate === "") { return; }

        var startMoment = moment(this.startDate, oldValue);
        var endMoment = moment(this.endDate, oldValue);
        this._isInternalStartDateUpdate = true;
        this.startDate = startMoment.format(format);
        this._isInternalStartDateUpdate = false;
        this._isInternalEndDateUpdate = true;
        this.endDate = endMoment.format(format);
        this._isInternalEndDateUpdate = false;

        this._updateDayIdentifiers(format, oldValue);

        this._fireStartDateChanged(this.startDate);
        this._fireEndDateChanged(this.endDate);
      },
      startDateChanged: function (newValue, oldValue) {
        if (this._isInternalStartDateUpdate) { return; }
        this._initializeAtCarbonDatePicker();

        // parameter can be null, undefined, numbers and in incorrect format
        // we need to validate it and log errors if invalid
        var startValid = moment(newValue, this.format, true).isValid();
        if (!startValid) {
          return;
        }

        this._updateCurrentMoment();

        this._refreshCalendar(this.startDate, this.endDate);
      },
      endDateChanged: function (newValue, oldValue) {
        if (this._isInternalEndDateUpdate) { return; }
        this._initializeAtCarbonDatePicker();

        // parameter can be null, undefined, numbers and in incorrect format
        // we need to validate it and log errors if invalid
        var endValid = moment(newValue, this.format, true).isValid();
        if (!endValid) {
          return;
        }

        this._updateCurrentMoment();

        this._refreshCalendar(this.startDate, this.endDate);
      },
      endChanged: function (newValue, oldValue) {
        this._initializeAtCarbonDatePicker();
        if (this.startDate && this.endDate){
          this._updateCurrentMoment();
        }

        this._refreshCalendar(this.startDate, this.endDate);
      },
      _backClicked: function () {
        this._moveMonth(-1);
      },
      _nextClicked: function () {
        this._moveMonth(1);
      },
      _moveMonth: function (n) {
        this._currentMoment.add(n, 'month');
        this._refreshCalendar(this.startDate, this.endDate);
      },
      _updateCurrentMoment: function () {
        var selectedDate = this._getSelectedDate(this.end, this.startDate, this.endDate);
        var selectedMoment = moment(selectedDate, this.format, true);
        var currentMoment = this._createCurrentMomentFor(selectedMoment);
        this._currentMoment = currentMoment;
      },
      _dateClicked: function (event) {
        var element = event.target;
        var dayIdentifier = element.getAttribute('day-identifier');
        if (dayIdentifier) {

          if (this.end) {
            this._isInternalEndDateUpdate = true;
            this.endDate = dayIdentifier;
            this._isInternalEndDateUpdate = false;
          } else {
            this._isInternalStartDateUpdate = true;
            this.startDate = dayIdentifier;
            this._isInternalStartDateUpdate = false;
          }

          this._refreshCalendar(this.startDate, this.endDate);

          this._fireStartDateChanged(this.startDate);
          this._fireEndDateChanged(this.endDate);
        }
      },
      _getSelectedDate: function (isEnd, startDate, endDate) {
        if (isEnd) {
          return endDate;
        } else {
          return startDate;
        }
      },
      _refreshCalendar: function (startDate, endDate) {
        var locale = this.getLocale();
        var selectedDate = this._getSelectedDate(this.end, startDate, endDate);
        var selectedMoment = moment(selectedDate, this.format).locale(locale);

        var startDateMoment = moment(startDate, this.format).locale(locale);
        var endDateMoment = moment(endDate, this.format).locale(locale);

        var firstOfMonthMoment = this._currentMoment;
        var firstDayOfMonthOffset = firstOfMonthMoment.day();
        var startIndex = 0 - firstDayOfMonthOffset;

        // these two lines update the UI
        this._year = firstOfMonthMoment.year();
        this._monthName = firstOfMonthMoment.format("MMMM");
        var self = this;
        var calendarBody = Polymer.dom(this.$.calendarBody);
        var calendarRows = calendarBody.querySelectorAll('.calendar-row');
        calendarRows.forEach(function (calendarRow, rowIndex) {
          var days = Polymer.dom(calendarRow).querySelectorAll('.day');
          days.forEach(function (day, dayIndex) {
            var offset = startIndex + rowIndex*7 + dayIndex;
            var clone = firstOfMonthMoment.clone();
            clone.add(offset, 'days');
            var dayIdentifier = clone.format(self.format);
            day.setAttribute('day-identifier', dayIdentifier);
            day.innerHTML = clone.date();

            Polymer.dom(day).classList.remove('selected');
            Polymer.dom(day).classList.remove('next-prev-month');
            Polymer.dom(day).classList.remove('start-date');
            Polymer.dom(day).classList.remove('end-date');
            Polymer.dom(day).classList.remove('in-range');
            if (clone.isSame(selectedMoment)) {
              Polymer.dom(day).classList.add('selected');
            }
            if (clone.month() !== firstOfMonthMoment.month()) {
              Polymer.dom(day).classList.add('next-prev-month');
            }
            if (clone.isSame(startDateMoment)) {
              Polymer.dom(day).classList.add('start-date');
            }
            if (clone.isSame(endDateMoment)) {
              Polymer.dom(day).classList.add('end-date');
            }
            if ((clone.isSame(startDateMoment) || clone.isAfter(startDateMoment)) && (clone.isSame(endDateMoment) || clone.isBefore(endDateMoment))) {
              Polymer.dom(day).classList.add('in-range');
            }

          });
        });

      },
      _updateDayIdentifiers: function (newFormat, oldFormat) {
        var self = this;
        var calendarBody = Polymer.dom(this.$.calendarBody);
        var calendarRows = calendarBody.querySelectorAll('.calendar-row');
        calendarRows.forEach(function (calendarRow, rowIndex) {
          var days = Polymer.dom(calendarRow).querySelectorAll('.day');
          days.forEach(function (day, dayIndex) {
            var currentIdentifier = day.getAttribute('day-identifier');
            if (currentIdentifier) {
              var currentMoment = moment(currentIdentifier, oldFormat, true);
              var newIdentifier = currentMoment.format(newFormat);
              Polymer.dom(day).setAttribute('day-identifier', newIdentifier);
            }
          });
        });
      },
      _fireStartDateChanged: function (newValue) {
        this.fire('start-date-changed', { value: newValue });
      },
      _fireEndDateChanged: function (newValue) {
        this.fire('end-date-changed', { value: newValue });
      }
    });
  </script>
</dom-module>
